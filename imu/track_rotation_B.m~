function [x,T, q, q12e, p12e] = track_rotation_B(time1, w1, acc1, time2, w2, \
					acc2, bandwidth, q12, p12, \
						 fixp12, fixq12)
%  [x,T, q12e] = track_rotation_B(time1, w1, acc1, time2, w2, \
%%					acc2, bandwidth, q12, p12)
% Tracks the rotation of a rigid body using data from two gyros and two accelerometers using
% algorithm B 
%
% Input
%    time1       ->   time stamps from node 1
%    w1          ->   gyro data (3 x nfr) from node 1
%    acc1        ->   accelerometer data (3 x nfr) from node 1
%    time1       ->   time stamps from node 1
%    w2          ->   gyro data (3 x nfr) from node 2
%    acc2        ->   accelerometer data (3 x nfr) from node 2
%    bandwidth   ->   Filter tuning parameter
%    q12         ->   Quaternion. Initial guess of orientation between
%                     the nodes
% Output
%    x           <-   the estimated state vectors (6 x nfrs)
%    T           <-   the time stamp of each estimate

%% Kjartan Halvorsen
%% 2012-05-21. 
%%

 if (nargin == 0)
   do_unit_test();
   %%do_unit_test();
 else

   if (nargin < 10)
     fixp12 = 0;
   end

   if (nargin < 11)
     fixq12 = 0;
   end

   
   dt0 = median(time1(100:150) - time1(99:149)); 
   %dt0 = 0.01; % hardcoded.

   resfunc = "residual_twoimu";
   if fixp12
     if fixq12
       A = eye(9,9);
       Q = zeros(9,9);
       P = zeros(9,9);
       resparams = {q12, cat(1, p12, fixq12)};
       x0 = zeros(9,1);
     else
       Q = zeros(12,12);
       P = zeros(12.12);
       Q(10:12, 10:12) = dt0*eye(3)*(2*pi/180)^2;
       P(10:12,10:12) = eye(3)*(4*pi/180)^2; %% Covariance of initial guess of
       %% orientation between sensors
       resparams = {q12, p12};
       x0 = zeros(12,1);
       A = eye(12,12);
       A(10:12,10:12) = 0;
     end
   else
     if fixq12
       A = eye(12,12);
       Q = zeros(12,12);
       P = zeros(12.12);
       Q(10:12, 10:12) = dt0*eye(3)*(0.001)^2;
       P(10:12,10:12) = eye(3)*(0.0005)^2; %% Covariance of initial guess of
       resparams = {q12, fixq12};
       x0 = zeros(12,1);
       x0(10:12) = p12;
       %%x0 = zeros(9,1);
       %%A = eye(9,9);
     else
       Q = zeros(15,15);
       P = zeros(15,15);
       Q(10:12, 10:12) = dt0*eye(3)*(1*pi/180)^2;
       Q(13:15, 13:15) = dt0*eye(3)*(0.001)^2;
       P(10:12, 10:12) = eye(3)*(4*pi/180)^2; %% Covariance of initial guess of
       P(13:15,13:15) = eye(3)*(0.0005)^2; %% Covariance of initial guess of
       resparams = {q12};
       x0 = zeros(15,1);
       x0(13:15) = p12;
       A = eye(15,15);
       A(10:12,10:12) = 0;
     end 
   end 

   A(1:3,4:6) = eye(3)*dt0;

   x0(1:3) = w1(:,1);
   x0(7:9) = acc1(:,1);
   %%x0(4:6) = (w1(:,2) - w1(:,1)) / dt0;

   %% Use cont white noise acc model
   I3a = eye(3)*(10000*pi/180)^2; %% (grad/s/s)^2
   Q(1:3,1:3) = 0.3333*dt0^3*I3a;
   Q(1:3,4:6) = 0.5*dt0^2*I3a;
   Q(4:6,1:3) = 0.5*dt0^2*I3a;
   Q(4:6,4:6) = dt0*I3a;
   
   Q(7:9, 7:9) = dt0*eye(3)*(80^2); % Acc
   Q(7:9, 7:9) = dt0*eye(3)*(100^2); % Acc

   %%P(1:9, 1:9) = Q(1:9, 1:9)/dt0;
   %%P(4:6,4:6) = 10*eye(3);
   P(1:3, 1:3) = eye(3)*(20*pi/180)^2;
   P(4:6, 4:6) = eye(3)*(100*pi/180)^2;
   P(7:9, 7:9) = eye(3)*(100)^2;

   nfr1 = length(time1);
   nfr2 = length(time2);
   
   sd_w = 10 * pi /180 ; % in rad/s
   sd_acc = 40 ; % in m/s/s
   sd_w = 6 * pi /180 ; % in rad/s
   sd_acc = 1 ; % in m/s/s
   R = zeros(12,12);
   R(1:3,1:3) = eye(3)*sd_w^2;
   R(4:6,4:6) = eye(3)*sd_acc^2;
   R(7:9, 7:9) = R(1:3,1:3);
   R(10:12, 10:12) = R(4:6,4:6);

   x = zeros(length(x0), nfr1+nfr2);
   T = nan(nfr1+nfr2,1);
   q12e = zeros(nfr1+nfr2,4);
   p12e = zeros(3,nfr1+nfr2);
   q = zeros(nfr1+nfr2, 4);
   qq = [0 0 0 1]';

   currentTime = min(time1(1), time2(1))-dt0;
   xc = x0; % current estimate
   fr1 = 1;
   fr2 = 1;
   nan6 = nan(6,1);


   k=0;
   while ( (fr1 <= length(time1)) & (fr2 <= length(time2)))
     t1 = time1(fr1);
     t2 = time2(fr2);
     %% Same timestamp or next data from sensor 2 arrives first
     if (abs(t1-t2) < dt0) % assume instantenous
       ctime = max(t1,t2);
       dt = ctime - currentTime;
       currentTime = ctime;
       y = cat(1, w1(:,fr1), acc1(:, fr1), w2(:,fr2), acc2(:,fr2));
       fr2 = fr2 + 1;
       fr1 = fr1 + 1;
     else 
       if (t1 < t2)
	 dt = t1 - currentTime;
	 currentTime = t1;
	 y = cat(1, w1(:,fr1), acc1(:,fr1), nan6);
	 fr1 = fr1 + 1;
       else
	 dt = t2 - currentTime;
	 currentTime = t2;
	 y = cat(1, nan6, w2(:,fr2), acc2(:,fr2));
	 fr2 = fr2 + 1;
       end
     end
     
     for its = 1:ceil(dt/dt0)
       xc = A*xc;
       P = A*P*A' + Q;
     end
     %%keyboard
     resparams{1} = q12;
     [xc,P] = ekf_update(y, xc, P, \
			 resfunc, resparams, R);
     if (~fixq12)
       q12 = qmult(q12, qexp(xc(10:12)));
     end
     %%disp(sprintf("%3.2f", 1/dt))
     qq = qmult(qexp(dt*xc(1:3)), qq);
     k = k+1;
     x(:,k) = xc;
     T(k) = currentTime;
     q(k,:) = qq;
     q12e(k,:) = q12;
   end
   q = q';
   q12e = q12e';
   keep = find(~isnan(T));
   x = x(:, keep);
   T = T(keep);
   q = q(:,keep);
   q12e = q12e(:,keep);
 end 

function   [wb1, accb1, ab1] = generate_data(N, w0, dt, axs, r, \
					   q12, g);
  modf = 1 + sin(linspace(-pi/2,3*pi/2,N));
  wb = w0*modf;
  time1 = (0:N-1)*dt;
  angleb = cumtrapz(time1, wb);
  %% Scale wb so that it becomes a complete revolution
  wb = wb*2*pi/angleb(end);

  ab = (centraldiff(wb',1/dt))';

  wb1 = zeros(3, N);
  wb1(axs,:) = wb;
  
  ab1 = zeros(3,N);
  ab1(axs,:) = ab;

  if (length(r) == 3)
    
    accb1 = zeros(3, N);
    for i=1:N
      accb1(:,i) = slave_acc(zeros(3,1), wb1(:,i), ab1(:,i), r);
    end
  else
    zN = zeros(1,N);
    switch axs
      case 1
	accb1 =  cat(1, zN, -wb.^2*r, ab*r);
      case 2
	accb1 =  cat(1, ab*r, zN, -wb.^2*r);
      case 3
	accb1 =  cat(1, -wb.^2*r, ab*r, zN);

    end 
  end
  accb1 = accb1 + repmat(g, 1, N);
  wb1 = qrot(wb1,q12);
  accb1 = qrot(accb1,q12);


function do_unit_test()
  disp("Unit test for function track_rotation_B")
  debug = 0;

  loaddata = 2; %% Loads tracked data and generates movement from this
  clipdata = 500*pi/180; %% If >0, taken to mean that angular velocty
                         %% data saturate. Data samples above the value
                         %% given are set to nan.
  clipdata = 0;
  switch loaddata
      case 1
	dta = load("./mocapdata/mc200_3_smooth");
	startfr = 150;
	endfr = size(dta.w,2);
	Nfr = endfr - startfr + 1;
    
	dt = 1/125;
	g = 9.82*[0;0;1];
	w0 = 10;
	r = 0.65;
    
	pL = dta.y(1:3, startfr);
	pR = dta.y(4:6, startfr);
	paddelc = 0.5*(pL+pR);
	vLR = pR-pL;
	vLR = vLR / norm(vLR);
	p1 = 0.65*vLR;
	p2 = -0.65*vLR;
	q12 = quaternion(randn(3,1), pi/3);
    
	
	wb1 = dta.w(:,startfr:endfr);
	accb1 = zeros(3, Nfr);
	accb2 = zeros(3, Nfr);

	for i=1:Nfr
	  acenterb = qtransv(dta.a(:,i+startfr-1), qinv(dta.q(:,i+startfr-1)));
	  accb1(:,i) = slave_acc(acenterb, wb1(:,i), dta.alpha(:,i+startfr-1), p1) + g;
	  accb2(:,i) = slave_acc(acenterb, wb1(:,i), dta.alpha(:,i+startfr-1), p2) + g;
	end
	
	accb2 = qrot(accb2, q12);
	wb2 = qrot(wb1, q12);
	
	q0 = dta.q(:,startfr:endfr);
	q0inv = zeros(4,Nfr);
	for i=1:Nfr
	  q0inv(:,i) = qinv(q0(:, i));
	end

	%%complete_revolutions = [25 176 325 469 615 763 910 1054 1201 1352 \
	%%		    1506 1657 1803];
	complete_revolutions = [325 469 615 763 910 1054 1201 1352 \
				1506 1657 1803] - startfr;
      case 2
	cycles = 10
	dta = load("periodic-realistic");
	N = size(dta.w,2);
	wb1 = dta.w;
	accb1 = zeros(3, N);
	accb2 = zeros(3, N);
	vLR = randn(3,1);
	vLR = vLR/norm(vLR);
	p1 = -0.25*vLR;
	p2 = 0.25*vLR;
	q12 = quaternion(randn(3,1), pi/3);
	for i=1:N
	  acenterb = qtransv(dta.a(:,i), qinv(dta.q(:,i)));
	  accb1(:,i) = slave_acc(acenterb, wb1(:,i), dta.alpha(:,i), p1);
	  accb2(:,i) = slave_acc(acenterb, wb1(:,i), dta.alpha(:,i), p2);
	end
	accb2 = qrot(accb2, q12);
	wb2 = qrot(wb1, q12);
	
	wb1 = repmat(wb1, 1, cycles);
	wb2 = repmat(wb2, 1, cycles);
	accb1 = repmat(accb1, 1, cycles);
	accb2 = repmat(accb2, 1, cycles);
	
	dt = 1/125;
	Nfr = N*cycles;
	complete_revolutions = cat(2, 1, (N-1:N:Nfr));
	
	q0 = dta.q;
	q0inv = zeros(4,N);
	for i=1:N
	  q0inv(:,i) = qinv(q0(:,i));
	end
	q0 = repmat(q0, 1, cycles); 
	q0inv = repmat(q0inv, 1, cycles); 

	alpha0 = repmat(dta.alpha, 1, cycles);
	%%keyboard
      case 0  
	
	%% Create data of two nodes rotating about a fixed axis going through
	%% the origin 
	
	cycles = 12
	N = 100;
	w0 = 200 * pi / 180; % rad/s
	axes = [3,2];
	dt = 0.01;
	r = 0.25;
	r2 = -r;
	g = 9.82*randn(3,1); %% The g vector
	%%g = 9.82*zeros(3,1); %% The g vector
	d12 = 1;
	q12 = quaternion(randn(3,1), pi/3);
	%%q12 = [0 0 0 1];
	q11 = [0 0 0 1]; % no rotation
	
	p1 = [0; r; 0];
	p2 = [0; r2; 0];

	[wb1z, accb1z, alphab1z] = generate_data(N, w0, dt, 3, p1, \
						 q11, g);
	[wb1y, accb1y, alphab1y] = generate_data(N, w0, dt, 2, p1, \
						 q11, g);
	wb1 = repmat(cat(2, wb1z, wb1y), 1, cycles);
	alphab1 = repmat(cat(2, alphab1z, alphab1y), 1, cycles);
	Nfr = size(wb1,2);
	
	%%[wb2z, accb2z] = generate_data(N, w0, dt, 3, p2, q12, g);
	%%[wb2y, accb2y] = generate_data(N, w0, dt, 2, p2, q12, g);
	q12 = quaternion(randn(3,1), pi/3);
	
	accb1 = zeros(3, Nfr);
	accb2 = zeros(3, Nfr);
	acenterb = [0;0;0];
	for i=1:Nfr
	  accb1(:,i) = slave_acc(acenterb, wb1(:,i), alphab1(:,i), p1) + g;
	  accb2(:,i) = slave_acc(acenterb, wb1(:,i), alphab1(:,i), p2) + g;
	end

	accb2 = qrot(accb2, q12);
	wb2 = qrot(wb1, q12);

	%%wb1 = repmat(cat(2, wb1z, wb1y), 1, cycles);
	%%wb2 = repmat(cat(2, wb2z, wb2y), 1, cycles);
	%%accb1 = repmat(cat(2, accb1z, accb1y), 1, cycles);
	%%accb2 = repmat(cat(2, accb2z, accb2y), 1, cycles);
	
	complete_revolutions = cat(2, 1, (N-1:N:Nfr));

	%%  The orientation of the body, computed by integrating the
	%%  error-free data using the trapezoidal rule
	q0 = zeros(4,Nfr);
	q0inv = zeros(4,Nfr);
	q00 = [0;0;0;1];
	q0(:,1) = q00;
	q0inv(:,1) = q00;
	for i=2:Nfr
	  q00 = qmult(q00, qexp(dt*0.5*(wb1(:,i-1)+wb1(:,i))));
	  q0(:,i) = q00;
	  q0inv(:,i) = qinv(q00);
	end
    end %% if loaddata

  wb1true = wb1;
  wb2true = wb2;
  accb1true = accb1;
  accb2true = accb2;
  if clipdata
    wb11 = wb1(:,1);
    wb21 = wb2(:,1);
    wb1(find(wb1>clipdata)) = nan;
    wb2(find(wb1>clipdata)) = nan;
    wb1(find(wb1<-clipdata)) = nan;
    wb2(find(wb1<-clipdata)) = nan;
    %% Make sure the first data frame is not nan
    wb1(:,1) = wb11;
    wb2(:,1) = wb21;
  end


  cycles = length(complete_revolutions) -1;
  p120 = p2 -p1;
  q120 = q12;
  

  time1 = (1:size(wb1, 2))*dt;
  time2 = (1:size(wb2, 2))*dt;

  
  fntsze = 12;
  lwdth = 6;
  SNR = 10;
  bandwidth = 1;
  nreps = 2;
  fixp12 = 1;
  fixq12 = 1;
  q21 = qinv(q120);
  
  param = (0:6:20)*1e-3; %% Range over which to check parameters
  param = [0 15]*1e-3;
  param = [0 2 4 8 16 32]*1e-3;
  param = [0 8 32]*1e-3;
  paramq = repmat(1, 1, length(param));
  %%param = 0;

  errangleB = zeros(length(time1), 1);
  errangleA = zeros(length(time1), 1);
  errposB = zeros(length(time1), 1);

  rmseA = zeros(1, length(time1));
  rmseB = zeros(1, length(time1));
  rmse_ref = zeros(1, length(time1));
  [bf,af] = butter(4, 0.25);
  %[bf] = fir1(8, 0.25);
  af = 1;
  meanwA = zeros(1, length(time1));
  meanwB = zeros(1, length(time1));
  meanw_ref = zeros(1, length(time1));
  errqA = zeros(1, length(time1));
  errqB = zeros(1, length(time1));
  errq_ref = zeros(1, length(time1));
  %%meanerrqA = zeros(1, length(time1));
  %%meanerrqB = zeros(1, length(time1));
  %%meanerrq_ref = zeros(1, length(time1));

  errrevolB = zeros(cycles,1);
  errrevolA = zeros(cycles,1);
  errrevol_ref = zeros(cycles,1);

  erevolB = zeros(nreps,1);
  erevolA = zeros(nreps,1);
  erevol_ref = zeros(nreps,1);
  erevolpB = zeros(nreps,length(param));
  erevolpA = zeros(nreps,length(param));
  erevolp_ref = zeros(nreps,length(param));


  for ppi = 1:length(param)
    errrevolB = zeros(cycles,1);
    errrevolA = zeros(cycles,1);
    errrevol_ref = zeros(cycles,1);
    
    erevolB = zeros(nreps,1);
    erevolA = zeros(nreps,1);
    erevol_ref = zeros(nreps,1);
    for rep = 1: nreps
      warning(["Iteration: ", int2str(rep)])
      if fixp12
	%%p12 = p2-p1 + randn(3,1)*0.005; % Apriori estimate of pos of sensor 2 wrt sensor 1
	p12 = p2-p1 + randn(3,1)*param(ppi); 
      else
	p12 = p2-p1 + randn(3,1)*0.02; % Apriori estimate of pos of sensor 2 wrt sensor 1
      end
      if fixq12
	q12 = qmult(q120, quaternion(randn(3,1),pi*1/180)); 
	q12 = qmult(q120, quaternion(randn(3,1),pi*paramq(ppi)/180)); 
      else
	q12 = qmult(q120, quaternion(randn(3,1),pi*10/180)); 
				% Accuracy in apriori angle measurement
      end

    amplacc = mean(max(accb1,[], 2) - min(accb1,[], 2));
    amplw = mean(max(wb1, [], 2) - min(wb1, [], 2));
    %%ew = randn(size(wb1))'*w0/SNR;
    %%ew2 = randn(size(wb2))'*w0/SNR;
    %%eacc = randn(size(accb1))'*norm(p120)*w0^2/SNR;
    %%eacc2 = randn(size(accb2))'*r*w0^2/SNR;
    eacc = randn(size(accb1))'*amplacc/SNR;
    eacc2 = randn(size(accb2))'*amplacc/SNR;
    ew = randn(size(wb1))'*amplw/SNR;
    ew2 = randn(size(wb2))'*amplw/SNR;
    [b,a] = butter(4,0.4);
    eaccf = eacc;
    eaccf2 =eacc2;
    ewf = ew;
    ewf2 = ew2;
    %%eaccf = filtfilt(b,a,eacc);
    %%eaccf2 = filtfilt(b,a,eacc2);
    %%ewf = filtfilt(b,a,ew);
    %%ewf2 = filtfilt(b,a,ew2);

%  tic();
    [x, T, qB, q12B] = track_rotation_B(time1, wb1+ewf', accb1+eaccf', ...
					time2, wb2+ewf2', accb2+eaccf2',...
					bandwidth, q12, p12, fixp12, fixq12);
    [xA, TA, qA, q12A] = track_rotation_A(time1, wb1+ewf', ...
					time2, wb2+ewf2', ...
					bandwidth, q12, fixq12);

  %% Compute the RMS error in estimated angular velocity
  %% Reference: plain filtering of the data
    %%wb1f = filtfilt(b,a, (wb1'+ewf))';
  wb1f = filter(b,a, (wb1+ewf')')';
  rmse_repref = sqrt(mean((wb1f(1:3,:)-wb1).^2));

  rmse_repA = sqrt(mean((xA(1:3,:)-wb1true).^2));
  rmse_repB = sqrt(mean((x(1:3,:)-wb1true).^2));
  rmseA = rmseA + 1/rep*(rmse_repA - rmseA);
  rmseB = rmseB + 1/rep*(rmse_repB - rmseB);  
  rmse_ref = rmse_ref + 1/rep*(rmse_repref - rmse_ref);

  meanwA = meanwA + 1/rep*(mean(xA(1:3,:) - wb1true) - meanwA);
  meanwB = meanwB + 1/rep*(mean(x(1:3,:) - wb1true) - meanwB);
  meanw_ref = meanw_ref + 1/rep*(mean(wb1f(1:3,:) - wb1true) - meanw_ref);

  q0_ref = [0;0;0;1];
  q_ref = zeros(4, length(T));
  for i=1:length(T)
    eqf = qmult(q12B(:,i), q21);
    errangleB(i) = errangleB(i) + 1/rep*(2*acos(eqf(4))*180/pi - errangleB(i));
    eqf = qmult(q12A(:,i), q21);
    errangleA(i) = errangleA(i) + 1/rep*(2*acos(eqf(4))*180/pi - errangleA(i));
    eqf = qmult(qB(:,i), q0inv(:,i));
    errqB(i) = errqB(i) + 1/rep*(2*acos(eqf(4))*180/pi - errqB(i));
    eqf = qmult(qA(:,i), q0inv(:,i));
    errqA(i) = errqA(i) + 1/rep*(2*acos(eqf(4))*180/pi - errqA(i));
    q_ref(:,i) = q0_ref;
    if (i>1)
      ddt = time1(i) - time1(i-1);
      q0_ref = qmult(qexp(ddt*wb1f(1:3,i-1)), q0_ref);
    end
    eqf = qmult(q0_ref, q0inv(:,i));
    errq_ref(i) = errq_ref(i) + 1/rep*(2*acos(eqf(4))*180/pi - errq_ref(i));
    q_ref(:,i) = q0_ref;
  end

  if (size(x,1) > 9)
    if fixq12
      for i=1:length(T)
	errposB(i) = errposB(i) + 1/rep*(norm(x(10:12,i) - p120) - errposB(i));
      end
    else
      for i=1:length(T)
	errposB(i) = errposB(i) + 1/rep*(norm(x(13:15,i) - p120) - errposB(i));
      end
    end
  end

  %% Compute the error in orientation after a full revolution (accumulated)
  q0A = qinv(qA(:,complete_revolutions(1)));
  q0B = qinv(qB(:,complete_revolutions(1)));
  q0_ref = qinv(q_ref(:,complete_revolutions(1)));
  %%keyboard
  for i = 2:length(complete_revolutions)
    endr = complete_revolutions(i);
    eqf = qmult(qB(:,endr), q0B);
    eqa = 2*acos(eqf(4))*180/pi;
    if (eqa > 180)
      eqa = eqa - 360;
    end
    errrevolB(i-1) = errrevolB(i-1) + 1/rep*(abs(eqa) - errrevolB(i-1));
    if (i>3)
      erevolB(rep) = erevolB(rep) + 1/i*(abs(eqa) - erevolB(rep));
    end
    q0B = qinv(qB(:,endr));

    eqf = qmult(qA(:,endr), q0A);
    eqa = 2*acos(eqf(4))*180/pi;
    if (eqa > 180)
      eqa = eqa - 360;
    end
    errrevolA(i-1) = errrevolA(i-1) + 1/rep*(abs(eqa) - errrevolA(i-1));
    if (i>3)
      erevolA(rep) = erevolA(rep) + 1/i*(abs(eqa) - erevolA(rep));
    end
    q0A = qinv(qA(:,endr));

    eqf = qmult(q_ref(:,endr), q0_ref);
    eqa = 2*acos(eqf(4))*180/pi;
    if (eqa > 180)
      eqa = eqa - 360;
    end
    errrevol_ref(i-1) = errrevol_ref(i-1) + 1/rep*(abs(eqa) - errrevol_ref(i-1));
    if (i>3)
      erevol_ref(rep) = erevol_ref(rep) + 1/i*(abs(eqa) - erevol_ref(rep));
    end
    q0_ref = qinv(q_ref(:,endr));
  end 

  erevolpA(:,ppi) = erevolA;
  erevolpB(:,ppi) = erevolB;
  erevolp_ref(:,ppi) = erevol_ref;
end 
end 
 

%  keyboard
figh = [1 2 7 8 9]
pd.pln.timeCal = time1;
pd.pln.gyroCal = wb1'+ewf;
pd.pln.accCal = accb1'+eaccf;
pd.prn.timeCal = time2;
pd.prn.gyroCal = wb2'+ewf2;
pd.prn.accCal = accb2'+eaccf2;

%%if ~ (fixp12 || fixq12)
[wb2sim, accb2sim] = plot_imu_results(T, x, q12B, pd, 1, Nfr, figh, fixp12, p12, fixq12);
%%end

figure(figh(1))
hold on
plot(time1, wb1true')
plot(T(1:end-3),xA(1, 1:end-3)', 'c', 'linewidth', 2);
plot(T(1:end-3),xA(2, 1:end-3)', 'm', 'linewidth', 2);
plot(T(1:end-3),xA(3, 1:end-3)', 'y', 'linewidth', 2);
plot(time1, wb1f(1,:), 'k')


figure(figh(3))
hold on
plot(time1, accb1')

 
  figure(3)
  clf
  plot(time1, errangleB, 'r')
  hold on
  plot(time1, errangleA, 'm')
  
  box off
  set(findobj(gca, 'type', 'line'), 'linewidth', lwdth)
  set(findobj(gcf, '-property', 'fontsize'), 'fontsize', fntsze)
  ylabel('Degrees', 'fontsize', fntsze)
  xlabel('Time [s]', 'fontsize', fntsze)
  legend('Algorithm 2GA', 'Algorithm 2G')
  
  respth = date;
  mkdir(respth);

  print(fullfile(respth,"q12errorABsa.tex"), "-depslatexstandalone")
  %%print("q12errorAB.pdf", "-dpdf")
  %%print("q12errorAB.eps", "-depsc2")


  figure(4)
  clf
  if 1 
    cind = (1:length(errrevolB));
    plot(cind, errrevolB, 'rx', 'markersize', 16)
    hold on
    plot(cind, errrevolA, 'mx', 'markersize', 16)
    plot(cind, errrevol_ref, 'bx', 'markersize', 16)
  
    box off
    set(findobj(gca, 'type', 'line'), 'linewidth', 3)
    set(findobj(gcf, '-property', 'fontsize'), 'fontsize', fntsze)
    ylabel('Degrees', 'fontsize', fntsze)
    xlabel('Revolution', 'fontsize', fntsze)
    if clipdata
      legend('Algorithm B', 'Algorithm A')
    else
      legend('Algorithm B', 'Algorithm A', 'LP filter')
    end
    set(gca, 'xlim', [0.5 length(errrevolB)+0.2])
    %%set(gca, 'xtick', [1 2 3 4])
  else
    legh = boxPlot(cat(2, erevolA, erevolB, erevol_ref));
  end    
  print(fullfile(respth,"qerrorABsa.tex"), "-depslatexstandalone")
  %print("qerrorAB.eps", "-depsc2")

  figure(5)
  clf
  plot(time1, errposB, 'r', 'linewidth', lwdth);
  ylabel('Distance [m]', 'fontsize', fntsze)
  xlabel('Time [s]', 'fontsize', fntsze)
  set(findobj(gcf, '-property', 'fontsize'), 'fontsize', fntsze)

  print(fullfile(respth,"p12errorsa.tex"), "-depslatexstandalone")
  print("p12errorAB.pdf", "-dpdf")
  print("p12errorAB.eps", "-depsc2")
  
  

  %% frind = (1:length(rmseB));
%% subplot(211)
%% plot(frind(1:end-3), rmseB(1:end-3)*180/pi, 'r')
%% hold on
%% plot(frind(1:end-3), rmseA(1:end-3)*180/pi, 'm')
%% plot(frind(1:end-3), rmse_ref(1:end-3)*180/pi, 'b')
%% 
%% box off
%% set(findobj(gca, 'type', 'line'), 'linewidth', 3)
%% set(findobj(gcf, '-property', 'fontsize'), 'fontsize', fntsze)
%% ylabel('RMS error (degrees/s)', 'fontsize', fntsze)
%% %%xlabel('Sample number', 'fontsize', fntsze)
%% legend('Algorithm B', 'Algorithm A', 'LP filter')
%%
%% subplot(212)
%% plot(frind(1:end-3), meanwB(1:end-3)*180/pi, 'r')
%% hold on
%% plot(frind(1:end-3), meanwA(1:end-3)*180/pi, 'm')
%% plot(frind(1:end-3), meanw_ref(1:end-3)*180/pi, 'b')
%% 
%% box off
%% set(findobj(gca, 'type', 'line'), 'linewidth', 3)
%% set(findobj(gcf, '-property', 'fontsize'), 'fontsize', fntsze)
%% ylabel('Average residual (degrees/s)', 'fontsize', fntsze)
%% xlabel('Sample number', 'fontsize', fntsze)
%% legend('Algorithm B', 'Algorithm A',' LP filter')
%%
%% print(fullfile(respth,"w_rmseAB.tex"), "-depslatexstandalone")
%%

  figure(6)
  clf
  cind = (1:length(errqA));
  plot(cind, errqB, 'r', 'linewidth', 4)
  hold on
  plot(cind, errqA, 'm', 'linewidth', 4)
  plot(cind, errq_ref, 'b', 'linewidth', 4)
  
  box off
  set(findobj(gca, 'type', 'line'), 'linewidth', 3)
  set(findobj(gcf, '-property', 'fontsize'), 'fontsize', fntsze)
  ylabel('Degrees', 'fontsize', fntsze)
  xlabel('Sample number', 'fontsize', fntsze)
  if clipdata
    legend('Algorithm B', 'Algorithm A')
  else
    legend('Algorithm B', 'Algorithm A', 'LP filter')
  end
    
  print(fullfile(respth, "qerrABsa.tex"), "-depslatexstandalone")
  

  figure(figh(5))
  hold on
  plot(time2, accb2')

  figure(8)
  clf
  if (size(x,1)==15)
    plot((x(13:15,:)-repmat(p120, 1, size(x,2)))')
  end

  figure(10)
  clf
  plot(param, mean(erevolpA), 'm', 'linewidth', lwdth)
  hold on
  plot(param, mean(erevolpB), 'r', 'linewidth', lwdth)
  plot(param, mean(erevolp_ref), 'b', 'linewidth', lwdth)
  legend('Algorithm 2G', 'Algorithm 2GA', 'LP filter + int')
    xlabel('Error in pf', 'fontsize', fntsze) 
  ylabel('Error in attitude', 'fontsize', fntsze) 
  set(findobj(gcf, '-property', 'fontsize'), 'fontsize', fntsze)
  print(fullfile(respth,"sensitivity_pf.tex"), "-depslatexstandalone")
  print(fullfile(respth,"sensitivity_pf.pdf"), "-dpdf")


  save("-binary", fullfile(respth, "results"))


  if (loaddata == 2)
    figure(11)
    clf
    plot(alpha0')
    hold on
    plot(x(4:6,:)', 'linewidth', 2)
  end

  figure(12)
  interv = complete_revolutions(4):complete_revolutions(6);
  clf
  plot(T(interv),xA(1, interv)', 'm', 'linewidth', 3);
  hold on
  plot(T(interv),x(1,interv)', 'r', 'linewidth', 3);
  plot(time1(interv), wb1f(1,interv), 'b', 'linewidth', 3)
  plot(time1(interv), wb1(1,interv), 'k', 'linewidth', 2)
  plot(time1(interv), (wb1(1,interv) + ewf(interv,1)'), 'k')
  set(gca, 'ylim', [-13 5])
  set(gca, 'xlim', [3.3 5.8])
  set(gca, 'ytick', [-10 0 5])
  set(gca, 'xtick', [4 5])
  xlabel('Time [s]')
  ylabel('Ang vel [rad/s]')
  set(findobj(gcf, '-property', 'fontsize'), 'fontsize', 12)
  legend('2G', '2GA', 'LP', 'location', 'south')
  %set(lgh, 'fontsize', 10)
  print(fullfile(respth,"example-wb1x"), "-depslatexstandalone")
  print(fullfile(respth,"example-wb1x.pdf"), "-dpdf")
  

 keyboard

