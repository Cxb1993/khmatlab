function [x,T, q, q12e] = track_rotation_A(time1, w1, time2, w2, \
					   bandwidth, q12, fixq12)
%  [x,T] = track_rotation_A(time1, w1, time2, w2, bandwidth, q12)
% Tracks the rotation of a rigid body using data from two gyros using
% algorithm A from 
%
% Input
%    time1       ->   time stamps from node 1
%    w1          ->   gyro data (3 x nfr) from node 1
%    time1       ->   time stamps from node 1
%    w2          ->   gyro data (3 x nfr) from node 2
%    bandwidth   ->   Filter tuning parameter
%    q12         ->   Quaternion. Initial guess of orientation between
%                     the nodes
% Output
%    x           <-   the estimated state vectors (6 x nfrs)

%% Kjartan Halvorsen
%% 2012-05-21. 
%%

 r2 = 1; % relation between cov matrices for node 1 and 2
 if (nargin == 0)
   do_unit_test();
   %%do_unit_test();
 else
   
   if (nargin < 7)
     fixq12 = 0;
   end

   resfunc = "residual_twogyro";
   
   dt0 = (time1(100) - time1(99)); 
   dt0 = 0.01; % hardcoded.


   if fixq12
     A = eye(3);
     Q = zeros(3,3);
     Q(1:3,1:3) = dt0*eye(3)*(1)^2;
     P = Q/dt0;
     resparams = {[], fixq12};
     x0 = w1(:,1);
   else
     A = zeros(6,6);
     A(1:3,1:3) = eye(3);
     Q(1:3,1:3) = dt0*eye(3)*(1)^2;
     Q(4:6,4:6) = dt0*eye(3)*(4*pi/180)^2;
     P = Q/dt0;
     P(4:6,4:6) = eye(3);
     resparams = {[]};
     x0 = zeros(6,1);
     x0(1:3) = w1(:,1);
   end

   nfr1 = length(time1);
   nfr2 = length(time2);

   sd_w = 10 * pi /180 ; % in rad/s
   sd_w = 20 * pi /180 ; % in rad/s
   R = eye(6)*sd_w^2;

   x = zeros(length(x0), nfr1+nfr2);
   T = nan(nfr1+nfr2,1);
   q12e = zeros(nfr1+nfr2,4);
   q = zeros(nfr1+nfr2, 4);
   qq = [0 0 0 1];

   currentTime = min(time1(1), time2(1))-dt0;
   xc = x0; % current estimate
   fr1 = 1;
   fr2 = 1;
   nan3 = nan(3,1);

   dt0half = dt0/2;
   k=0;
   while ( (fr1 <= length(time1)) & (fr2 <= length(time2)))
     t1 = time1(fr1);
     t2 = time2(fr2);
     %%xc(4:6) = 0; % The orientation of imu2 wrt imu1 considered constant. 
     xc = A*xc;
     if (abs(t1-t2) < dt0half)
       ctime = max(t1,t2);
       dt = ctime - currentTime;
       currentTime = ctime;
       y = cat(1, w1(:,fr1), w2(:,fr2));
       fr1 = fr1 + 1;
       fr2 = fr2 + 1;
     else
       if (t1 < t2)
	 dt = t1 - currentTime;
	 currentTime = t1;
	 y = cat(1, w1(:,fr1), nan3);
	 fr1 = fr1 + 1;
       else % next data from sensor 2 arrives first
	 dt = t2 - currentTime;
	 currentTime = t2;
	 y = cat(1, nan3, w2(:,fr2));
	 fr2 = fr2 + 1;
       end
     end
     
     for its = 1:ceil(dt/dt0)
       P = A*P*A' + Q;
     end
     resparams{1} = q12;
     [xc,P] = ekf_update(y, xc, P, \
			 resfunc, resparams , R);
     %%keyboard
     if (length(xc)>3)
       q12 = qmult(q12, qexp(xc(4:6)));
     end
     qq = qmult(qexp(dt*xc(1:3)), qq);
     %%keyboard
     k = k+1;
     q(k,:) = qq;
     x(:,k) = xc;
     T(k) = currentTime;
     q12e(k,:) = q12;
   end   
   q = q';
   q12e = q12e';
   keep = find(~isnan(T));
   x = x(:, keep);
   T = T(keep);
   q = q(:,keep);
   q12e = q12e(:,keep);
 end

function   [wb1, wb2, accb1, accb2] = generate_dataA(N, w0, dt, axs, r, \
					   q12, d12, g);
  modf = 1 + sin(linspace(-pi/2,3*pi/2,N));
  wb = w0*modf;
  ab = (centraldiff(wb',1/dt))';

  wb1 = zeros(3, N);
  wb1(axs,:) = wb;
  wb2 = qrot(wb1,q12);
  
  zN = zeros(1,N);
  switch axs
    case 1
      accb1 =  cat(1, zN, -wb.^2*r, ab*r);
    case 2
      accb1 =  cat(1, ab*r, zN, -wb.^2*r);
    case 3
      accb1 =  cat(1, -wb.^2*r, ab*r, zN);
  end 
  accb2 = qrot(accb1,q12);

function do_unit_test()
  disp("Unit test for function track_rotation_A")
  debug = 0;
  ekf = 1;

  %% Create data of rigid body rotating about a fixed axis going through
  %% the origin and in the z-direction.
  %% Let the first imu be located at [1;0;0] initially and the second at
  %% [2;0;0]. The second is rotated about its x-axis 

  cycles = 6
  N = 100;
  w0 = 200 * pi / 180; % rad/s
  axes = [3,2];
  dt = 0.01;
  r = 0.5;
  g = 9.82*randn(3,1); %% The g vector
  d12 = 1;
  q12 = quaternion([1;0;0], pi/3);

  [wb1z, wb2z] = generate_data(N, w0, dt, 3, r, \
					   q12, d12, g);
  [wb1y, wb2y] = generate_data(N, w0, dt, 2, r, \
					   q12, d12, g);

  wb1 = repmat(cat(2, wb1z, wb1y), 1, cycles);
  wb2 = repmat(cat(2, wb2z, wb2y), 1, cycles);
  accb1 = repmat(cat(2, accb1z, accb1y), 1, cycles);
  accb2 = repmat(cat(2, accb2z, accb2y), 1, cycles);
  


  q12e = quaternion(randn(3,1),pi*10/180); % Accuracy in apriori angle measurement
  q0 = [0;0;0;1];
  d0 = [r;0;0];
  v = [0;0;1];


  N = size(wb1,2);

  qs = zeros(4,N);
  w = zeros(3,N);
  d = zeros(3,N);
  
  qi = q0;
  for i=1:N
    qi = qpropagate(qi,wb1(:,i),dt);
    qs(:,i) = qi;
    d(:,i) = -d0 + qtransv(d0,qi);
  end

  SNR = 10;
  eacc = randn(size(accb1))'*r*w0^2/SNR;
  eacc2 = randn(size(accb2))'*r*w0^2/SNR;
  ew = randn(size(wb1))'*5/180*pi;
  ew2 = randn(size(wb2))'*5/180*pi;
  [b,a] = butter(4,0.8);
  eaccf = filtfilt(b,a,eacc);
  eaccf2 = filtfilt(b,a,eacc2);
  ewf = filtfilt(b,a,ew);
  ewf2 = filtfilt(b,a,ew2);

  tic();
  [dd, vv, accs, qq, ws, qf, df] = track_twonode(accb1+eaccf', wb1+ewf', \
					 accb2+eaccf2', wb2+ewf2', dt, \
						 1, qmult(q12e,q12), ekf);
  %%[dd, vv, accs, qq, ws, qf, df] = track_twonode(accb1+eaccf', wb1, \	
  %%				 accb2+eaccf2', wb2, dt, \
  %%						 1, qmult(q12e,q12), ekf);


  toc()

  dds = zeros(3,N);
  dds(:,1) = dd(:,1);

  errangle = zeros(N,1);
  erranglef = zeros(N,1);
  accb2 = zeros(3,N);
  q21 = qinv(q12);
  for i=1:N
    eq = qmult(qs(:,i), qinv(qq(:,i)));
    eqf = qmult(qf(:,i), q21);
    errangle(i) = 2*acos(eq(4))*180/pi;
    erranglef(i) = 2*acos(eqf(4))*180/pi;
    if (i>1)
      dds(:,i) = dds(:,i-1) + dt*vv(:,i-1);
    end 
    accb2(:,i) = qtransv(accs(:,i), qinv(qq(:,i)));
  end


  figure(1)
  clf
  plot(d(1,:), d(2,:));
  hold on
  plot(dd(1,:), dd(2,:), 'r');
  %plot(dds(1,:), dds(2,:), 'm');
  legend('True path', 'Estimated path')

  d1 = [1;0;0];
  d1s = zeros(3,N);
  for i=1:N
    d1s(:,i) = qtransv(d1,qq(:,i));
  end

  figure(2)
  clf
  plot3(d1s(1,:), d1s(2,:), d1s(3,:))

  figure(3)
  clf
  tid = (1:N)*dt;
  plot(tid,errangle, 'b')
  hold on
  plot(tid, erranglef,'r')
  legend('orientation error', 'q12 error')
  ylabel('Degrees')
  xlabel('Time')

  if debug
    [ath, ar] = cart2pol(accs(1,:), accs(2,:));
    figure(4)
    clf
    subplot(211)
    plot(ath*180/pi)
    subplot(212)
    plot(ar)

    [vth, vr] = cart2pol(vv(1,:), vv(2,:));
    figure(5)
    clf
    subplot(211)
    plot(vth*180/pi)
    subplot(212)
    plot(vr)
  end

 keyboard

