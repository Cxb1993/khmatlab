function [r, pred, drdx]=residual_twoimu(y, x, q, pqfix)
%%  [r, pred, drdx]=residual_twoimu(y, x, q, pqfix)
%%
%% Residual (measurement) function for algorithm B (both gyros and
%% accelerometers).
%% The state vector is 
%%       x=[w alpha a th p], 
%% and the measurements are
%%       y = [wm am ws as].
%% The measurement functions are
%%       wm = h1(x) = w 
%%       am = h2(x) = a 
%%       ws = h3(x) = q*exp(th)*w*exp(-th)*qconj 
%%       ws = h4(x) = q*exp(th)*a2*exp(-th)*qconj,
%% where the acceleration of the slave node in the body frame of the
%% master node is 
%%       a2 = a  +  w x w x p  +  alpha x p
%%
%% Input
%%    y      ->   the current measurement
%%    x      ->   the current state. 
%%    q      ->   the previous orientation of the slave
%%                node. The current orientation is
%%                qn = q*exp(th).
%%   pqfix   ->   Optional. If 3-vector: The position of the slave
%%               node. If scalar, assume q fixed. In either case the state vector is
%%               assumed to have length 12. If length 4, both are fixed.
%% Output
%%    r       <-   the residual y - pred

% Kjartan Halvorsen
% 2012-05-20
%
%

if (nargin == 0)
  do_unit_test();
else
  
  w = x(1:3);
  alpha = x(4:6);
  a = x(7:9);

  fixq = 1;
  fixp = 0;
  th = zeros(3,1);
  if (nargin < 4)
    fixq = 0;
    qind = 10:12;
    th  = x(qind);
    pind = 13:15;
    p = x(pind);
  else
    if (length(pqfix) > 1)
      p = pqfix(1:3);
      fixp = 1;
    end	
    if (length(pqfix) == 1)
      pind = (10:12);
      p = x(pind);
      if (pqfix(1) == 0)
	fixq = 0;
	qind = 10:12;
	th  = x(qind);
      end
    end
    if (length(pqfix) == 3)
      fixq = 0;
      qind = 10:12;
      th  = x(qind);
    end
  end
  %%keyboard

  [eth, dethdth, decthdth] = qexp(th);
  qe = qmult(q, eth);
  qec = qconj(qe);
  qc = qconj(q);

  %% For faster execution
  Rqe = quaternion2rotation(qe);

  [a2, da2dw, da2dalpha, da2dp] = slave_acc(a, w, alpha, p);

  pred = cat(1, ...
	     w, ...
	     a, ...
	     Rqe*w, ...
	     Rqe*a2);

  r = y-pred;

  dqdw = zeros(4,3);
  for i=1:3
    dqdw(:,i) = qmult(q, dethdth(:,i));
  end

  dh3dw = Rqe;
  [h3, dh3dth] = qrotexp(cat(1,w,0), q, th, qc, qe, qec, dqdw);
  [h4, dh4dth] = qrotexp(cat(1, a2, 0), q, th, qc, qe, qec, dqdw);
 
  I3 = eye(3);
  drdx = zeros(12, length(x));
  if (~fixp)
    drdx(10:12, pind) = -Rqe*da2dp;
  end
  if (~fixq)
    drdx(10:12, qind) = -dh4dth(1:3,:);
    drdx(7:9, qind) = -dh3dth(1:3,:);
  end
  drdx(1:3,1:3) = -I3;
  drdx(4:6, 7:9) = -I3;
  drdx(7:9, 1:3) = -dh3dw;
  drdx(10:12, 1:3) = -Rqe*da2dw;
  drdx(10:12, 4:6) = -Rqe*da2dalpha;
  drdx(10:12, 7:9) = -Rqe;
  end
end

function do_unit_test()
  disp("Unit test for function residual_twoimu")

  tol = 1e-6;
  dx = 1e-8;
  dt = 0.01;

  q = (quaternion(randn(3,1), rand(1)))';

  y = randn(12,1);
  x = randn(15,1);
  x(9:11) = pi*4/180*randn(3,1);

  I15 = eye(15);

  [r, pred, drdx] = residual_twoimu(y, x, q);
  
  dr_dx = zeros(12,15);
  for i = 1:15
    dr_dx(:,i) = ( residual_twoimu(y, x+dx*I15(:,i), q) - r ) / dx;
  end
  
  if ( norm(drdx - dr_dx) > tol )
    disp('Test 1. Failed')
    drdx
    dr_dx
    keyboard
  else
    disp('Test 1. OK')
  end

  x = randn(12,1);
  x(9:11) = pi*4/180*randn(3,1);
  I12 = eye(12);
  pp = randn(3,1);
  [r, pred, drdx] = residual_twoimu(y, x, q, pp);
  
  dr_dx = zeros(12,12);
  for i = 1:12
    dr_dx(:,i) = ( residual_twoimu(y, x+dx*I12(:,i), q, pp) - r ) / dx;
  end
  
  if ( norm(drdx - dr_dx) > tol )
    disp('Test 2. Failed')
    drdx
    dr_dx
    keyboard
  else
    disp('Test 2. OK')
  end

