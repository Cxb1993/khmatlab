function [r, pred, drdx]=residual_twogyro(y, x, q)
%%  [r, pred, drdx]=residual_twogyro(y, x, q)
%%
%% Residual (measurement) function for algorithm A (only gyro data
%% The state vector is 
%%       x=[w th], 
%% and the measurements are
%%       y = [wm ws].
%% The measurement functions are
%%       wm = h1(x) = w 
%%       ws = h2(x) = q*exp(th)*w*exp(-th)*qconj 
%%
%% Input
%%    y      ->   the current measurement
%%    x      ->   the current state. 
%%    q      ->   the previous orientation of the slave node. The current orientation is
%%                  qn = q*exp(th).
% Output
%    r       <-   the residual y - pred

% Kjartan Halvorsen
% 2012-05-21
%
%

if (nargin == 0)
  do_unit_test();
else
  
  w = x(1:3);
  th  = x(4:6);

  [eth, dethdth, decthdth] = qexp(th);
  qe = qmult(q, eth);
  qec = qconj(qe);
  qc = qconj(q);

  %% For faster execution
  Rqe = quaternion2rotation(qe);
  pred = cat(1, ...
	     w, ...
	     Rqe*w);

  r = y-pred;

  dqdw = zeros(4,3);
  for i=1:3
    dqdw(:,i) = qmult(q, dethdth(:,i));
  end

  dh2dw = Rqe;
  [h2, dh2dth] = qrotexp(cat(1,w,0), q, th, qc, qe, qec, dqdw);
 
  I3 = eye(3);
  drdx = zeros(6, 6);
  drdx(1:3,1:3) = -I3;
  drdx(4:6, 1:3) = -dh2dw;
  drdx(4:6, 4:6) = -dh2dth(1:3,:);

end

function do_unit_test()
  disp("Unit test for function residual_twoimu")

  tol = 1e-6;
  dx = 1e-8;
  dt = 0.01;

  q = (quaternion(randn(3,1), rand(1)))';

  y = randn(6,1);
  x = randn(6,1);
  x(4:6) = pi*4/180*randn(3,1);

  I6 = eye(6);

  [r, pred, drdx] = residual_twogyro(y, x, q);
  
  dr_dx = zeros(6,6);
  for i = 1:6
    dr_dx(:,i) = ( residual_twogyro(y, x+dx*I6(:,i), q) - r ) / dx;
  end
  
  if ( norm(drdx - dr_dx) > tol )
    disp('Test 1. Failed')
    drdx
    dr_dx
    keyboard
  else
    disp('Test 1. OK')
  end

