function [nallmarkers, npg] = rotatec3dmarkers(newmarkers, allmarkers, pg, names)
%  [nallmarkers, npg] = extractc3dmarkers(newmarkers, allmarkers, pg, names)
% Sets the trajectories for the marker names provided.
%
% Input
%   newmarkers      ->  marker data to add. (nfrs x 3 nnmarks) or
%                       (nfrs x nnmarks x 3)
%   allmarkers      ->  marker data as returned by readC3D (nfrs x
%                       nmarkers x 3)
%   pg              ->  parameter group
%   names           ->  cell array of names. If doesn't exist in
%                       data, then add 
% Output
%   nallmarkers     <-  new set of markers
%   npg             <-  new parameter group

% Kjartan Halvorsen
% 2005-03-06

labels = getc3dparam(pg, 'POINT', 'LABELS');

[slask, distind, nameind] = intersect(labels.data, names);

if (size(newmarkers, 3) == 1)
  newmarkers = reshape(permute(newmarkers,[1 3 2]), ...
		       [size(newmarkers,1) size(newmarkers,2)/3 3]);
end

npg = pg;

if isempty(slask)
  % Add the markers
  nallmarkers = cat(2, allmarkers, newmarkers);
  
  % Set parametergroup
  param = getc3dparam(npg, 'POINT', 'USED');
  param.data = param.data + size(newmarkers, 2);
  npg = setc3dparam(npg, 'POINT', param);
  
  param = getc3dparam(npg, 'POINT', 'LABELS');
  param.data = cat(2, param.data, names);
  param.dim = [param.dim(1) param.dim(2)+length(names)];
  npg = setc3dparam(npg, 'POINT', param);
  
  param = getc3dparam(npg, 'POINT', 'DESCRIPTIONS');
  param.data = cat(2, param.data, names);
  param.dim = [param.dim(1) param.dim(2)+length(names)];
  npg = setc3dparam(npg, 'POINT', param);
  
else
  
  % Note that the indices are sorted. Fix this
  [slask, sortind] = sort(nameind);
  distind = distind(sortind);
    
  [nfrs, nmarkers, tre] = size(newmarkers);

  nallmarkers = allmarkers;
  
  for i=1:length(distind)
    nallmarker(:,distind(i),:) = newmarkers(:,i,:);
  end
end